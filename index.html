<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sneak Attack Game</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #e6e6e6;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* Info section */
    .info-section {
      margin: 20px;
      max-width: 900px;
      width: 90%;
    }

    .info-box {
      padding: 20px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      text-align: left;
    }

    .info-box h1 {
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 1.8rem;
      text-align: center;
    }

    .info-box h2 {
      margin-top: 0;
      font-size: 1.2rem;
    }

    ul {
      margin: 0;
      padding-left: 20px;
    }
    
      /* Turn indicator */
    #p1-glows {
      margin-top: 15px;
      font-weight: bold;
      text-align: center;
      font-size: 1.1rem;
      background-Color: lightsalmon;
      color: #333;
    }
    
     /* Turn indicator */
    #p2-glows {
      margin-top: 15px;
      font-weight: bold;
      text-align: center;
      font-size: 1.1rem;
      background-Color: lightsalmon;
      color: #333;
    }

    
     /* Turn indicator */
    #turn-indicator {
      margin-top: 15px;
      font-weight: bold;
      text-align: center;
      font-size: 1.1rem;
      /*color: #333;*/
      color: white; /* default text color */
    }

    /* Turn indicator */
  .turn-container {
  display: flex;
  justify-content: center;   /* center all HUD boxes horizontally */
  gap: 3rem;                 /* space between them */
  margin-bottom: 1rem;
  margin-top: 1rem;
}

.hud-box {
  background: rgba(255, 255, 255, 0.9);
  border-radius: 12px;       /* rounded corners */
  padding: 0.4em 1em;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25); /* button-like shadow */
  font-weight: bold;
  font-size: 1rem;
  min-width: 8ch;            /* ensure small consistent width */
  text-align: center;
}

    /* Game grid */
    .grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-template-rows: repeat(6, 1fr);
      aspect-ratio: 1/1;
      width: 90vmin;   /* square grid that fits viewport */
      height: auto;
      max-width: 600px;
      max-height: 600px;
      border: 2px solid #444;
      margin-bottom: 20px; /* extra space at bottom */
    }

    .cell {
      display: flex;
      justify-content: center;
      align-items: center;
      border: 1px solid #444;
      font-size: 5vmin; /* scales with screen */
    }
    
  .corner {
      border: 3px solid gold !important;
      box-shadow: 0 0 10px gold;
      animation: cornerGlow 0.75s infinite alternate;
   }
   
   @keyframes cornerGlow {
  from {
    box-shadow: 0 0 5px gold, 0 0 10px gold;
  }
  to {
    box-shadow: 0 0 20px gold, 0 0 40px gold;
  }
}

    .G { background-color: lightgreen; }
    .B { background-color: lightblue; }

    .p1 {
      font-size: 8vmin; /* bigger solid black circle */
      
    }
    .p2 {
     font-size: 8vmin; /* bigger solid blue circle */
      
    }
    /* Fullscreen overlay */
#overlay {
  position: fixed;
  inset: 0; /* shorthand for top/right/bottom/left: 0 */
  background: rgba(0,0,0,0.5); /* semi-transparent backdrop */
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000; /* ensure it's above everything */
}

/* Centered box */
.overlay-content {
  background: rgba(255,255,255,0.9);
  padding: 30px 50px;
  border-radius: 16px;
  text-align: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.25);
}

.overlay-content h1 {
  margin: 0 0 20px;
  font-size: 2rem;
}

/* target the UL inside the overlay-content (class) */
.overlay-content ul {
  text-align: left;         /* left-align bullet + text */
  margin: 0 auto;           /* keep the list block centered within overlay */
  padding-left: 1.25em;     /* space for bullets */
  list-style-position: outside;
  max-width: 48ch;          /* optional: keep line length readable */
}

/* optional: add spacing between items */
.overlay-content ul li {
  margin-bottom: 0.6em;
}

#begin-btn {
  padding: 10px 20px;
  font-size: 1rem;
  border: none;
  border-radius: 8px;
  background: #0077ff;
  color: white;
  cursor: pointer;
}

#begin-btn:hover {
  background: #005fcc;
}

.reset-container {
  display: flex;
  justify-content: center;
  margin-top: 1rem;
}

#reset-btn {
  background: crimson;
  color: white;
  font-size: 1rem;
  font-weight: bold;
  padding: 0.6em 1.2em;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  box-shadow: 0 3px 6px rgba(0,0,0,0.3);
  transition: background 0.3s ease;
}

#reset-btn:hover {
  background: darkred;
}

#reset-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}


/* Medium screens (tablets, smaller laptops) */
@media (max-width: 1000px) {
  .grid {
    width: 75vmin;
  }
  .hud-box {
    font-size: 1rem;
    padding: 8px 16px;
    min-width: 100px;
  }
  .reset-container button {
    font-size: 1rem;
    padding: 8px 16px;
  }
}

/* Small screens */
@media (max-width: 700px) {
  .grid {
    width: 60vmin;
  }
  .hud-box {
    font-size: 0.9rem;
    padding: 6px 12px;
    min-width: 90px;
  }
  .reset-container button {
    font-size: 0.9rem;
    padding: 6px 12px;
  }
}

/* Extra small screens (phones) */
@media (max-width: 500px) {
  .grid {
    width: 50vmin;
  }
  .hud-box {
    font-size: 0.8rem;
    padding: 5px 10px;
    min-width: 80px;
  }
  .reset-container button {
    font-size: 0.8rem;
    padding: 5px 10px;
  }
}
  </style>
</head>
<body>
  <div id="overlay">
  <div class="overlay-content">
    <h1>Sneak Attack Game</h1>
     <h2>How to Play</h2>
    <ul>
      <li><b>Player 1:</b> WASD = move, c = camouflage or remain still, <br> g = glow opponent, Space = attack</li>
      <li><b>Player 2:</b> Arrows = move, Shift = camouflage or remain still, <br> / = glow opponent, Enter = attack</li>
      <li> "Camouflage" makes the player the same color as the tile that the player is on. </li>
      <li>"Glow an opponent" removes the camouflage, and opponent becomes visible. </li>
      <li>Attack range = 2 Manhattan steps. If attack succeeds, you win! If attack fails, the opponent wins!</li>
      <li>The other way to win is to be first to reach the opposite corner.(Opponent's starting tile.) </li>
    </ul>
     <br>
      <button id="begin-btn">Begin Game</button>
  </div>
  </div>

  <!-- Info section -->
 <!-- <div class="info-section"> -->
 <!--   <div class="info-box">  -->
     <!-- <h1>Sneak Attack Game</h1> -->
     

      <!-- Turn indicator -->
     <div class="turn-container">
        <div class="hud-box" id="p1-glows">P1 Glows: 2</div>
        <div class="hud-box" id="turn-indicator">Player 1's Turn</div>
        <div class="hud-box" id="p2-glows">P2 Glows: 2</div>
     </div>
  <!--   </div> -->
  <!-- </div> -->

  <!-- Game Grid -->
  <div class="grid" id="game"></div>
  
  
<!-- Reset button -->
<div class="reset-container">
  <button id="reset-btn" disabled>Reset Game</button>
</div>

  <script>
    //The background music was created by Ikoliks, https://pixabay.com/music/meditationspiritual-meditation-music-322801/
    const bgAudio = new Audio("background-track.mp3");
    bgAudio.loop = true;
    bgAudio.volume = 0.1;  // so it stays background, not overwhelming
    const gridSize = 6;
    const colors = ["G", "B"];
    const turnIndicator = document.getElementById("turn-indicator");
    let gameOver = false; //flag used to disable movement when game is over
    let grid = [];
    // Movement offsets
    const directions = {
        w: [-1, 0], // up
        a: [0, -1], // left
        s: [1, 0],  // down
        d: [0, 1],  // right
        ArrowUp:    [-1, 0],
        ArrowLeft:  [0, -1],
        ArrowDown:  [1, 0],
        ArrowRight: [0, 1]
    };
    

    // Players
    let players = {
  P1: { 
    row: 0, 
    col: 0, 
    symbol: "‚óè", 
    css: "p1", 
    camouflaged: false,  // new field
    camouflagedColor: null,      // remembers what tile color they‚Äôre blending into
    glows: 2,
    defaultColor: "black",
    playerColor: "black"
  },
  P2: { 
    row: 5, 
    col: 5, 
    symbol: "‚óè", 
    css: "p2", 
    camouflaged: false,  // new field
    camouflagedColor: null,
    glows: 2,
    defaultColor: "blue",
    playerColor: "blue"
  }
};

    // Turn tracker
    let currentPlayer = "P1";

    // Generate grid with random colors
    for (let r = 0; r < gridSize; r++) {
      grid[r] = [];
      for (let c = 0; c < gridSize; c++) {
        grid[r][c] = colors[Math.floor(Math.random() * colors.length)];
      }
    }

    // Render grid
    function renderGrid() {
      let html = "";
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          let cellClass = grid[r][c];
          let symbol = "";
          let cssClass = "";
          if ((r === 0 && c === 0) || (r === gridSize - 1 && c === gridSize - 1)) {
            cellClass += " corner";
          }
          // Players
          if (players.P1.row === r && players.P1.col === c) {
            symbol = players.P1.symbol;
            cssClass = players.P1.css;
            html += `<div id="cell-${r}-${c}" class="cell ${cellClass} ${cssClass}" style="color:${players.P1.playerColor}">${symbol}</div>`;

          } else if (players.P2.row === r && players.P2.col === c) {
            symbol = players.P2.symbol;
            cssClass = players.P2.css;
            html += `<div id="cell-${r}-${c}" class="cell ${cellClass} ${cssClass}" style="color:${players.P2.playerColor}">${symbol}</div>`;
          } else {
                html += `<div id="cell-${r}-${c}" class="cell ${cellClass} ${cssClass}">${symbol}</div>`;
          }
        }
      }
      document.getElementById("game").innerHTML = html;
      if (currentPlayer === "P1") {
            turnIndicator.textContent = "Player 1's Turn";
            turnIndicator.style.color = "lightgray"; // Player 1 cue
            turnIndicator.style.backgroundColor = "black";
        }   else {
            turnIndicator.textContent = "Player 2's Turn";
            turnIndicator.style.color = "lightgray";  // Player 2 cue
            turnIndicator.style.backgroundColor = "blue";
            }
     
       document.getElementById("p1-glows").textContent = `P1 Glows: ${players.P1.glows}`;
       document.getElementById("p2-glows").textContent = `P2 Glows: ${players.P2.glows}`;
    }
    
   function resetGame() {
  // Reset players
  players = {
    P1: { row: 0, col: 0, symbol: "‚óè", css: "p1", camouflaged: false, camouflagedColor: null, glows: 2, playerColor: "black" },
    P2: { row: 5, col: 5, symbol: "‚óè", css: "p2", camouflaged: false, camouflagedColor: null, glows: 2, playerColor: "blue" }
  };

  // Reset turn
  currentPlayer = "P1";
  gameOver = false;

  // Reset HUD
  document.getElementById("p1-glows").textContent = `P1 Glows: 2`;
       document.getElementById("p2-glows").textContent = `P2 Glows: 2`;
  document.getElementById("turn-indicator").textContent = "Player 1's Turn";
  document.getElementById("turn-indicator").style.backgroundColor = "black";
  document.getElementById("turn-indicator").style.color = "white";
  
   // Generate grid with random colors
    for (let r = 0; r < gridSize; r++) {
      grid[r] = [];
      for (let c = 0; c < gridSize; c++) {
        grid[r][c] = colors[Math.floor(Math.random() * colors.length)];
      }
    }
  // Reset grid
  document.getElementById("reset-btn").disabled = true;
  renderGrid();

  // Show overlay again
  document.getElementById("overlay").style.display = "flex";
}

    renderGrid();
    // Handle key presses
    document.addEventListener("keydown", (e) => {
    if (gameOver) return;  // ignore keys if game ended
    const key = e.key;
  
  let player, opponent;
    if (currentPlayer === "P1") {
        player = players.P1;
        opponent = players.P2;
      } else {
        player = players.P2;
        opponent = players.P1;
      }
      
    // --- Attack Activation ---
    if ((currentPlayer ==="P1" && e.key === " ") || 
        (currentPlayer ==="P2" && e.key === "Enter")) {
      glowAttack(player);
       playVictoryChime();
      let distance = Math.abs(player.row - opponent.row) + Math.abs(player.col - opponent.col);
      if (distance <= 2) {
    // Successful attack
      player.symbol = "‚óè";
      opponent.symbol = "üí•";
      document.getElementById("reset-btn").disabled = false;
      gameOver = true;
      renderGrid();
    setTimeout(() => {
      console.log(currentPlayer);
      if (currentPlayer === "P1"){
      showMessage(`Player 1 wins with a successful attack!`);
      } else {
        showMessage(`Player 2 wins with a successful attack!`);
      //resetGame();
        }
    }, 50);
  } else {
    // Failed attack ‚Üí opponent wins
     player.symbol = "üí•";
      opponent.symbol = "‚óè";
      document.getElementById("reset-btn").disabled = false;
      gameOver = true;
      renderGrid();
    setTimeout(() => {
      if (currentPlayer === "P1"){
      showMessage(`Player 1 missed! Player 2 wins!`);
      } else showMessage(`Player 2 missed! Player 1 wins!`);
     // resetGame();
    }, 50);
  }
}
      
    // --- Glow opponent Activation ---
    if ((currentPlayer === "P1" && e.key === "g") ||
      (currentPlayer === "P2" && e.key === "/")) {
       //playChime();
       if (currentPlayer === "P1") {
        playChimeForPlayer("P1");
        } else {
        playChimeForPlayer("P2");
        }

    if (player.glows > 0) {
      player.glows--;

      // Reveal opponent if camouflaged
      if (opponent.camouflaged) {
        opponent.camouflaged = false;
        opponent.symbol = "‚óè";
        glowOpponent(opponent);
      }
        //alert(`${currentPlayer} used a Light Burst! Opponent revealed!`);
      } else {
        //alert(`${currentPlayer} used a Light Burst... but opponent wasn‚Äôt hidden.`);
      }

      // End turn
      if (currentPlayer === "P1") {
        currentPlayer = "P2";
        } else {
         currentPlayer = "P1";
        }
      renderGrid();
      return;
    } //else {
      //alert(`${currentPlayer} has no Glows left! Choose a different action`);
    //}
  
    
    
    // --- Camouflage keys ---
  if ((currentPlayer === "P1" && e.key === "c") || 
     (currentPlayer === "P2" && e.key === "Shift")) {
     // playChime();
     if (currentPlayer === "P1") {
        playChimeForPlayer("P1");
        } else {
        playChimeForPlayer("P2");
        }
    const camouflagedColor = grid[player.row][player.col];

    player.camouflaged = true;
    player.camouflagedColor = camouflagedColor;
    player.symbol = "";

    // End turn after camouflage
    if (currentPlayer === "P1") {
      currentPlayer = "P2";
    } else {
      currentPlayer = "P1";
    }

    renderGrid();
    return; // don‚Äôt check movement
  }
  
  // --- Move Action ---
   if ((currentPlayer === "P1" && e.key === "w") || 
       (currentPlayer === "P1" && e.key === "a") ||
       (currentPlayer === "P1" && e.key === "s") || 
       (currentPlayer === "P1" && e.key === "d") ||
       (currentPlayer === "P2" && e.key === "ArrowUp") || 
       (currentPlayer === "P2" && e.key === "ArrowDown") ||
       (currentPlayer === "P2" && e.key === "ArrowLeft") || 
       (currentPlayer === "P2" && e.key === "ArrowRight")){
        
        
        
        const dir = directions[key];
        const newRow = player.row + dir[0];
        const newCol = player.col + dir[1];

        // Stay inside grid bounds
        if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
        //playChime();
        if (currentPlayer === "P1") {
        playChimeForPlayer("P1");
        } else {
        playChimeForPlayer("P2");
        }
        player.row = newRow;
        player.col = newCol;
    
 
        // If a camouflaged player moves to a tile with a different color, they should no longer be camouflaged, and return to original color
        if (player.camouflaged) {
            if (grid[player.row][player.col] !== player.camouflagedColor) {
            // Different color ‚Üí break camouflage
            player.camouflaged = false;
            player.camouflagedColor = null;
            player.symbol = "‚óè";
            }
        }
   
        //check corner win
        checkCornerWin();
        if (!gameOver) {
        // Switch turns after a move
            if (currentPlayer === "P1") {
                currentPlayer = "P2";
            } else {
                currentPlayer = "P1";
            }
           
        }
    renderGrid();
    }
 
} });

// Robust interval-based glow that guarantees final color
function glowOpponent(opponent, duration = 1000) {
  // Defensive: cancel any previous glow for this opponent
  if (opponent._glowInterval) {
    clearInterval(opponent._glowInterval);
    delete opponent._glowInterval;
  }

  const originalColor = opponent.defaultColor || opponent.playerColor || "black";

  const glowColors = [
    "#ffff66", "#fff176", "#ffee58", "#ffeb3b", "#fdd835", "#fbc02d",
    "#f9a825", "#f57f17", "#ff9800", "#fb8c00", "#f57c00", "#ef6c00"
  ];

  const steps = glowColors.length;
  const intervalTime = Math.max(10, Math.round(duration / steps)); // ms per step
  let step = 0;

  // Make sure the opponent is visible before starting the glow
  opponent.symbol = "‚óè";

  // store interval id so we can clear it later if needed
  opponent._glowInterval = setInterval(() => {
    // update playerColor and re-render
    opponent.playerColor = glowColors[step];
    renderGrid();

    step++;

    if (step >= steps) {
      // finished: clear interval and restore original color
      clearInterval(opponent._glowInterval);
      delete opponent._glowInterval;

      // set the logical color back to the original
      opponent.playerColor = originalColor;

      // final render to sync DOM
      renderGrid();

      // Force a browser reflow/repaint and explicitly set the final color on the cell element.
      // This makes the final color stick even if some other small repaint race happens.
      const cellId = `cell-${opponent.row}-${opponent.col}`;
      // Use requestAnimationFrame twice to let browser process the render
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          const cellEl = document.getElementById(cellId);
          if (cellEl) {
            // directly set inline style as a last-resort guarantee of appearance
            cellEl.style.color = originalColor;
            // if you animate background instead, use:
            // cellEl.style.backgroundColor = originalColor;
          }
        });
      });
    }
  }, intervalTime);
}

function glowAttack(attacker) {
let glowColors = [
    "#ffff66", "#fff176", "#ffee58", "#ffeb3b", "#fdd835", "#fbc02d",
    "#f9a825", "#f57f17", "#ff9800", "#fb8c00", "#f57c00", "#ef6c00"
  ];

  const intervalTime = 1000 / glowColors.length; // 1 second total
  let step = 0;
  //console.log("here");
  //grid[1][1]="purple";
  //document.getElementById('cell-1-1').style.backgroundColor = "purple"; // update display
  // Collect all cells within Manhattan distance 2
  const cellsToGlow = [];
  for (let r = 0; r < 6; r++) {
    for (let c = 0; c < 6; c++) {
      if (Math.abs(attacker.row - r) + Math.abs(attacker.col - c) <= 2) {
        cellsToGlow.push({ row: r, col: c });
      }
    }
  }

 for (let colorIndex = 0; colorIndex < glowColors.length; colorIndex++) {
  setTimeout(function () {
    // inner loop over glowing cells
    for (let i = 0; i < cellsToGlow.length; i++) {
      const cell = cellsToGlow[i];
      const cellEl = document.getElementById(`cell-${cell.row}-${cell.col}`);
      if (cellEl) {
        cellEl.style.backgroundColor = glowColors[colorIndex];
        //console.log("Setting color:", glowColors[colorIndex]);
      }
    }
  }, colorIndex * 200); // delay increases with each color step
}
}

function checkCornerWin() {
  if (players.P1.row === 5 && players.P1.col === 5) {
    showMessage("Player 1 Wins by reaching the corner!");
    players.P2.symbol = "üí•"; // explosion for loser
    gameOver = true;
    document.getElementById("reset-btn").disabled = false;
    renderGrid();
    playVictoryChime();
   //  bgAudio.pause();
   //         bgAudio.currentTime = 0;
  } else if (players.P2.row === 0 && players.P2.col === 0) {
    showMessage("Player 2 Wins by reaching the corner!");
    players.P1.symbol = "üí•"; // explosion for loser
    gameOver = true;
    playVictoryChime();
    document.getElementById("reset-btn").disabled = false;
    renderGrid();
  }
}

function showMessage(msg) {
  const messageBox = document.createElement("div");
  messageBox.textContent = msg;
  messageBox.style.position = "fixed";
  messageBox.style.top = "40%";
  messageBox.style.left = "50%";
  messageBox.style.transform = "translate(-50%, -50%)";
  messageBox.style.background = "rgba(0,0,0,0.7)";
  messageBox.style.color = "white";
  messageBox.style.padding = "20px 40px";
  messageBox.style.borderRadius = "12px";
  messageBox.style.fontSize = "2rem";
  messageBox.style.zIndex = "1000";
  document.body.appendChild(messageBox);
  setTimeout(() => {
    messageBox.remove();  // <- this deletes the message
  }, 4000);
  
}

// Define fixed chime frequencies for each player
const playerChimes = {
  P1: 329.63, // E4
  P2: 392.00  // G4
};

function playChimeForPlayer(playerId) {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();

  const freq = playerChimes[playerId]; // fixed tone per player

  // Main oscillator
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = "sine";
  osc.frequency.value = freq;

  gain.gain.setValueAtTime(0.2, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 2.0);

  osc.connect(gain).connect(ctx.destination);

  // Add a subtle shimmer
  const osc2 = ctx.createOscillator();
  const gain2 = ctx.createGain();
  osc2.type = "sine";
  osc2.frequency.value = freq * 1.01;
  gain2.gain.setValueAtTime(0.05, ctx.currentTime);
  gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 2.0);
  osc2.connect(gain2).connect(ctx.destination);

  osc.start();
  osc.stop(ctx.currentTime + 2.0);
  osc2.start();
  osc2.stop(ctx.currentTime + 2.0);
}


function playChime() {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();

  // Midrange pentatonic (C4‚ÄìE5 range, no super low tones)
  const pentatonic = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25];

  // Pick a random midrange note
  const freq = pentatonic[Math.floor(Math.random() * pentatonic.length)];

  // Main oscillator
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = "sine";
  osc.frequency.value = freq;

  gain.gain.setValueAtTime(0.2, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 2.0);

  osc.connect(gain).connect(ctx.destination);

  // Add subtle richness with a slightly detuned oscillator
  const osc2 = ctx.createOscillator();
  const gain2 = ctx.createGain();
  osc2.type = "sine";
  osc2.frequency.value = freq * 1.01; // gentle shimmer
  gain2.gain.setValueAtTime(0.05, ctx.currentTime);
  gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 2.0);
  osc2.connect(gain2).connect(ctx.destination);

  osc.start();
  osc.stop(ctx.currentTime + 2.0);
  osc2.start();
  osc2.stop(ctx.currentTime + 2.0);
}

function playVictoryChime() {
  // Play 3 chimes spaced 300ms apart
  playChime();
  setTimeout(() => playChime(), 300);
  setTimeout(() => playChime(), 600);
}

     
    document.getElementById("begin-btn").addEventListener("click", () => {
    document.getElementById("overlay").style.display = "none";
   // üéµ Later, you can also start your game music here
   bgAudio.play();
   document.getElementById("reset-btn").addEventListener("click", resetGame);
     renderGrid();
    });

  </script>
</body>
</html>
